:mod:`avalanche.models.dynamic_modules`
=======================================

.. py:module:: avalanche.models.dynamic_modules

.. autoapi-nested-parse::

   Dynamic Modules are Pytorch modules that can be incrementally expanded
   to allow architectural modifications (multi-head classifiers, progressive
   networks, ...).



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   avalanche.models.dynamic_modules.DynamicModule
   avalanche.models.dynamic_modules.MultiTaskModule
   avalanche.models.dynamic_modules.IncrementalClassifier
   avalanche.models.dynamic_modules.MultiHeadClassifier
   avalanche.models.dynamic_modules.TrainEvalModel



.. py:class:: DynamicModule

   Bases: :class:`torch.nn.Module`

   Dynamic Modules are Avalanche modules that can be incrementally
   expanded to allow architectural modifications (multi-head
   classifiers, progressive networks, ...).

   Compared to pytoch Modules, they provide an additional method,
   `model_adaptation`, which adapts the model given data from the
   current experience.

   Initializes internal Module state, shared by both nn.Module and ScriptModule.

   .. method:: adaptation(self, dataset: AvalancheDataset = None)

      Adapt the module (freeze units, add units...) using the current
      data. Optimizers must be updated after the model adaptation.

      Avalanche strategies call this method to adapt the architecture
      *before* processing each experience. Strategies also update the
      optimizer automatically.

      .. warning::
          As a general rule, you should NOT use this method to train the
          model. The dataset should be used only to check conditions which
          require the model's adaptation, such as the discovery of new
          classes or tasks.

      :param dataset: data from the current experience.
      :return:


   .. method:: train_adaptation(self, dataset: AvalancheDataset)

      Module's adaptation at training time.

      Avalanche strategies automatically call this method *before* training
      on each experience.


   .. method:: eval_adaptation(self, dataset: AvalancheDataset)

      Module's adaptation at evaluation time.

      Avalanche strategies automatically call this method *before* evaluating
      on each experience.

      .. warning::
          This method receives the experience's data at evaluation time
          because some dynamic models need it for adaptation. For example,
          an incremental classifier needs to be expanded even at evaluation
          time if new classes are available. However, you should **never**
          use this data to **train** the module's parameters.



.. py:class:: MultiTaskModule

   Bases: :class:`torch.nn.Module`

   Multi-task modules are `torch.nn.Modules`s for multi-task
   scenarios. The `forward` method accepts task labels, one for
   each sample in the mini-batch.

   By default the `forward` method splits the mini-batch by task
   and calls `forward_single_task`. Subclasses must implement
   `forward_single_task` or override `forward.

   Initializes internal Module state, shared by both nn.Module and ScriptModule.

   .. method:: forward(self, x: torch.Tensor, task_labels: torch.Tensor) -> torch.Tensor

      compute the output given the input `x` and task labels.

      :param x:
      :param task_labels: task labels for each sample.
      :return:


   .. method:: forward_single_task(self, x: torch.Tensor, task_label: int) -> torch.Tensor
      :abstractmethod:

      compute the output given the input `x` and task label.

      :param x:
      :param task_label: a single task label.
      :return:



.. py:class:: IncrementalClassifier(in_features, initial_out_features=2)

   Bases: :class:`avalanche.models.dynamic_modules.DynamicModule`

   Dynamic Modules are Avalanche modules that can be incrementally
   expanded to allow architectural modifications (multi-head
   classifiers, progressive networks, ...).

   Compared to pytoch Modules, they provide an additional method,
   `model_adaptation`, which adapts the model given data from the
   current experience.

   Output layer that incrementally adds units whenever new classes are
   encountered.

   Typically used in class-incremental benchmarks where the number of
   classes grows over time.

   :param in_features: number of input features.
   :param initial_out_features: initial number of classes (can be
       dynamically expanded).

   .. method:: adaptation(self, dataset: AvalancheDataset)

      If `dataset` contains unseen classes the classifier is expanded.

      :param dataset: data from the current experience.
      :return:


   .. method:: forward(self, x, **kwargs)

      compute the output given the input `x`. This module does not use
      the task label.

      :param x:
      :return:



.. py:class:: MultiHeadClassifier(in_features, initial_out_features=2)

   Bases: :class:`avalanche.models.dynamic_modules.MultiTaskModule`, :class:`avalanche.models.dynamic_modules.DynamicModule`

   Multi-task modules are `torch.nn.Modules`s for multi-task
   scenarios. The `forward` method accepts task labels, one for
   each sample in the mini-batch.

   By default the `forward` method splits the mini-batch by task
   and calls `forward_single_task`. Subclasses must implement
   `forward_single_task` or override `forward.

   Multi-head classifier with separate heads for each task.

   Typically used in task-incremental benchmarks where task labels are
   available and provided to the model.

   .. note::
       Each output head may have a different shape, and the number of
       classes can be determined automatically.

       However, since pytorch doest not support jagged tensors, when you
       compute a minibatch's output you must ensure that each sample
       has the same output size, otherwise the model will fail to
       concatenate the samples together.

       These can be easily ensured in two possible ways:
       - each minibatch contains a single task, which is the case in most
           common benchmarks in Avalanche. Some exceptions to this setting
           are multi-task replay or cumulative strategies.
       - each head has the same size, which can be enforced by setting a
           large enough `initial_out_features`.

   :param in_features: number of input features.
   :param initial_out_features: initial number of classes (can be
       dynamically expanded).

   .. method:: adaptation(self, dataset: AvalancheDataset)

      If `dataset` contains new tasks, a new head is initialized.

      :param dataset: data from the current experience.
      :return:


   .. method:: forward_single_task(self, x, task_label)

      compute the output given the input `x`. This module uses the task
      label to activate the correct head.

      :param x:
      :param task_label:
      :return:



.. py:class:: TrainEvalModel(feature_extractor, train_classifier, eval_classifier)

   Bases: :class:`avalanche.models.dynamic_modules.DynamicModule`

   TrainEvalModel.
   This module allows to wrap together a common feature extractor and
   two classifiers: one used during training time and another
   used at test time. The classifier is switched when `self.adaptation()`
   is called.

   :param feature_extractor: a differentiable feature extractor
   :param train_classifier: a differentiable classifier used
       during training
   :param eval_classifier: a classifier used during testing.
       Doesn't have to be differentiable.

   .. method:: forward(self, x)


   .. method:: train_adaptation(self, dataset: AvalancheDataset = None)

      Module's adaptation at training time.

      Avalanche strategies automatically call this method *before* training
      on each experience.


   .. method:: eval_adaptation(self, dataset: AvalancheDataset = None)

      Module's adaptation at evaluation time.

      Avalanche strategies automatically call this method *before* evaluating
      on each experience.

      .. warning::
          This method receives the experience's data at evaluation time
          because some dynamic models need it for adaptation. For example,
          an incremental classifier needs to be expanded even at evaluation
          time if new classes are available. However, you should **never**
          use this data to **train** the module's parameters.



